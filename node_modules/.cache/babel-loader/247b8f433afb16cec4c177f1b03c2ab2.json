{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState, useEffect } from \"react\";\nimport { useCustomFetch } from \"./useCustomFetch\";\nexport function useTransactionsByEmployee() {\n  _s();\n\n  const {\n    fetchWithCache,\n    loading\n  } = useCustomFetch();\n  const [transactionsByEmployee, setTransactionsByEmployee] = useState(null); // ✅ Restore persisted transactions from localStorage on load\n\n  useEffect(() => {\n    const savedTransactions = localStorage.getItem(\"transactionsByEmployee\");\n\n    if (savedTransactions) {\n      setTransactionsByEmployee(JSON.parse(savedTransactions));\n    }\n  }, []);\n  const fetchById = useCallback(async employeeId => {\n    var _await$fetchWithCache;\n\n    const apiTransactions = (_await$fetchWithCache = await fetchWithCache(\"transactionsByEmployee\", {\n      employeeId\n    })) !== null && _await$fetchWithCache !== void 0 ? _await$fetchWithCache : []; // ✅ Ensure `apiTransactions` is always an array\n\n    setTransactionsByEmployee(prevTransactions => {\n      const savedTransactions = JSON.parse(localStorage.getItem(\"transactionsByEmployee\") || \"[]\"); // ✅ Merge API transactions with locally stored approvals\n\n      const updatedTransactions = apiTransactions.map(transaction => {\n        const locallyUpdated = savedTransactions.find(t => t.id === transaction.id);\n        return locallyUpdated ? { ...transaction,\n          approved: locallyUpdated.approved\n        } : transaction;\n      });\n      localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)); // ✅ Persist updates\n\n      return updatedTransactions;\n    });\n  }, [fetchWithCache]);\n  const invalidateData = useCallback(() => {\n    setTransactionsByEmployee(null);\n  }, []);\n  const updateTransactionApproval = useCallback((transactionId, newValue) => {\n    setTransactionsByEmployee(prevTransactions => {\n      if (!prevTransactions) return null;\n      const updatedTransactions = prevTransactions.map(t => t.id === transactionId ? { ...t,\n        approved: newValue\n      } : t);\n      localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)); // ✅ Store changes persistently\n\n      return updatedTransactions;\n    });\n  }, []);\n  return {\n    data: transactionsByEmployee,\n    loading,\n    fetchById,\n    invalidateData,\n    updateTransactionApproval\n  };\n}\n\n_s(useTransactionsByEmployee, \"oeyFvQkhdwa18cdX4M5OuFe74Yw=\", false, function () {\n  return [useCustomFetch];\n});","map":{"version":3,"names":["useCallback","useState","useEffect","useCustomFetch","useTransactionsByEmployee","fetchWithCache","loading","transactionsByEmployee","setTransactionsByEmployee","savedTransactions","localStorage","getItem","JSON","parse","fetchById","employeeId","apiTransactions","prevTransactions","updatedTransactions","map","transaction","locallyUpdated","find","t","id","approved","setItem","stringify","invalidateData","updateTransactionApproval","transactionId","newValue","data"],"sources":["D:/Assessments/Ramp/ramp-fe-challenge/src/hooks/useTransactionsByEmployee.ts"],"sourcesContent":["import { useCallback, useState, useEffect } from \"react\"\nimport { RequestByEmployeeParams, Transaction } from \"../utils/types\"\nimport { TransactionsByEmployeeResult } from \"./types\"\nimport { useCustomFetch } from \"./useCustomFetch\"\n\nexport function useTransactionsByEmployee(): TransactionsByEmployeeResult {\n  const { fetchWithCache, loading } = useCustomFetch()\n  const [transactionsByEmployee, setTransactionsByEmployee] = useState<Transaction[] | null>(null)\n\n  // ✅ Restore persisted transactions from localStorage on load\n  useEffect(() => {\n    const savedTransactions = localStorage.getItem(\"transactionsByEmployee\")\n    if (savedTransactions) {\n      setTransactionsByEmployee(JSON.parse(savedTransactions))\n    }\n  }, [])\n\n  const fetchById = useCallback(\n    async (employeeId: string) => {\n      const apiTransactions =\n        (await fetchWithCache<Transaction[], RequestByEmployeeParams>(\"transactionsByEmployee\", {\n          employeeId,\n        })) ?? [] // ✅ Ensure `apiTransactions` is always an array\n\n      setTransactionsByEmployee((prevTransactions) => {\n        const savedTransactions = JSON.parse(localStorage.getItem(\"transactionsByEmployee\") || \"[]\")\n\n        // ✅ Merge API transactions with locally stored approvals\n        const updatedTransactions = apiTransactions.map((transaction) => {\n          const locallyUpdated = savedTransactions.find((t: Transaction) => t.id === transaction.id)\n          return locallyUpdated ? { ...transaction, approved: locallyUpdated.approved } : transaction\n        })\n\n        localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)) // ✅ Persist updates\n\n        return updatedTransactions\n      })\n    },\n    [fetchWithCache]\n  )\n\n  const invalidateData = useCallback(() => {\n    setTransactionsByEmployee(null)\n  }, [])\n\n  const updateTransactionApproval = useCallback((transactionId: string, newValue: boolean) => {\n    setTransactionsByEmployee((prevTransactions) => {\n      if (!prevTransactions) return null\n\n      const updatedTransactions = prevTransactions.map((t) =>\n        t.id === transactionId ? { ...t, approved: newValue } : t\n      )\n\n      localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)) // ✅ Store changes persistently\n\n      return updatedTransactions\n    })\n  }, [])\n\n  return { data: transactionsByEmployee, loading, fetchById, invalidateData, updateTransactionApproval }\n}\n"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,QAAtB,EAAgCC,SAAhC,QAAiD,OAAjD;AAGA,SAASC,cAAT,QAA+B,kBAA/B;AAEA,OAAO,SAASC,yBAAT,GAAmE;EAAA;;EACxE,MAAM;IAAEC,cAAF;IAAkBC;EAAlB,IAA8BH,cAAc,EAAlD;EACA,MAAM,CAACI,sBAAD,EAAyBC,yBAAzB,IAAsDP,QAAQ,CAAuB,IAAvB,CAApE,CAFwE,CAIxE;;EACAC,SAAS,CAAC,MAAM;IACd,MAAMO,iBAAiB,GAAGC,YAAY,CAACC,OAAb,CAAqB,wBAArB,CAA1B;;IACA,IAAIF,iBAAJ,EAAuB;MACrBD,yBAAyB,CAACI,IAAI,CAACC,KAAL,CAAWJ,iBAAX,CAAD,CAAzB;IACD;EACF,CALQ,EAKN,EALM,CAAT;EAOA,MAAMK,SAAS,GAAGd,WAAW,CAC3B,MAAOe,UAAP,IAA8B;IAAA;;IAC5B,MAAMC,eAAe,4BAClB,MAAMX,cAAc,CAAyC,wBAAzC,EAAmE;MACtFU;IADsF,CAAnE,CADF,yEAGZ,EAHT,CAD4B,CAIhB;;IAEZP,yBAAyB,CAAES,gBAAD,IAAsB;MAC9C,MAAMR,iBAAiB,GAAGG,IAAI,CAACC,KAAL,CAAWH,YAAY,CAACC,OAAb,CAAqB,wBAArB,KAAkD,IAA7D,CAA1B,CAD8C,CAG9C;;MACA,MAAMO,mBAAmB,GAAGF,eAAe,CAACG,GAAhB,CAAqBC,WAAD,IAAiB;QAC/D,MAAMC,cAAc,GAAGZ,iBAAiB,CAACa,IAAlB,CAAwBC,CAAD,IAAoBA,CAAC,CAACC,EAAF,KAASJ,WAAW,CAACI,EAAhE,CAAvB;QACA,OAAOH,cAAc,GAAG,EAAE,GAAGD,WAAL;UAAkBK,QAAQ,EAAEJ,cAAc,CAACI;QAA3C,CAAH,GAA2DL,WAAhF;MACD,CAH2B,CAA5B;MAKAV,YAAY,CAACgB,OAAb,CAAqB,wBAArB,EAA+Cd,IAAI,CAACe,SAAL,CAAeT,mBAAf,CAA/C,EAT8C,CASsC;;MAEpF,OAAOA,mBAAP;IACD,CAZwB,CAAzB;EAaD,CApB0B,EAqB3B,CAACb,cAAD,CArB2B,CAA7B;EAwBA,MAAMuB,cAAc,GAAG5B,WAAW,CAAC,MAAM;IACvCQ,yBAAyB,CAAC,IAAD,CAAzB;EACD,CAFiC,EAE/B,EAF+B,CAAlC;EAIA,MAAMqB,yBAAyB,GAAG7B,WAAW,CAAC,CAAC8B,aAAD,EAAwBC,QAAxB,KAA8C;IAC1FvB,yBAAyB,CAAES,gBAAD,IAAsB;MAC9C,IAAI,CAACA,gBAAL,EAAuB,OAAO,IAAP;MAEvB,MAAMC,mBAAmB,GAAGD,gBAAgB,CAACE,GAAjB,CAAsBI,CAAD,IAC/CA,CAAC,CAACC,EAAF,KAASM,aAAT,GAAyB,EAAE,GAAGP,CAAL;QAAQE,QAAQ,EAAEM;MAAlB,CAAzB,GAAwDR,CAD9B,CAA5B;MAIAb,YAAY,CAACgB,OAAb,CAAqB,wBAArB,EAA+Cd,IAAI,CAACe,SAAL,CAAeT,mBAAf,CAA/C,EAP8C,CAOsC;;MAEpF,OAAOA,mBAAP;IACD,CAVwB,CAAzB;EAWD,CAZ4C,EAY1C,EAZ0C,CAA7C;EAcA,OAAO;IAAEc,IAAI,EAAEzB,sBAAR;IAAgCD,OAAhC;IAAyCQ,SAAzC;IAAoDc,cAApD;IAAoEC;EAApE,CAAP;AACD;;GAvDezB,yB;UACsBD,c"},"metadata":{},"sourceType":"module"}