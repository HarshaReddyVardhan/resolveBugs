{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState, useEffect } from \"react\";\nimport { useCustomFetch } from \"./useCustomFetch\";\nexport function useTransactionsByEmployee() {\n  _s();\n\n  const {\n    fetchWithCache,\n    loading\n  } = useCustomFetch();\n  const [transactionsByEmployee, setTransactionsByEmployee] = useState(null); // ✅ Restore persisted transactions from localStorage on first load\n\n  useEffect(() => {\n    const savedTransactions = localStorage.getItem(\"transactionsByEmployee\");\n\n    if (savedTransactions) {\n      setTransactionsByEmployee(JSON.parse(savedTransactions));\n    }\n  }, []);\n  const fetchById = useCallback(async employeeId => {\n    var _await$fetchWithCache;\n\n    const data = (_await$fetchWithCache = await fetchWithCache(\"transactionsByEmployee\", {\n      employeeId\n    })) !== null && _await$fetchWithCache !== void 0 ? _await$fetchWithCache : []; // ✅ Ensure `data` is always an array\n\n    setTransactionsByEmployee(prevTransactions => {\n      if (!prevTransactions) return data;\n      const updatedTransactions = data.map(transaction => {\n        const existingTransaction = prevTransactions.find(t => t.id === transaction.id);\n        return existingTransaction ? { ...transaction,\n          approved: existingTransaction.approved\n        } : transaction;\n      });\n      localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)); // ✅ Store merged transactions\n\n      return updatedTransactions;\n    });\n  }, [fetchWithCache]);\n  const invalidateData = useCallback(() => {\n    setTransactionsByEmployee(null);\n  }, []);\n  const updateTransactionApproval = useCallback((transactionId, newValue) => {\n    setTransactionsByEmployee(prevTransactions => {\n      if (!prevTransactions) return null;\n      const updatedTransactions = prevTransactions.map(t => t.id === transactionId ? { ...t,\n        approved: newValue\n      } : t);\n      localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)); // ✅ Store changes persistently\n\n      return updatedTransactions;\n    });\n  }, []);\n  return {\n    data: transactionsByEmployee,\n    loading,\n    fetchById,\n    invalidateData,\n    updateTransactionApproval\n  };\n}\n\n_s(useTransactionsByEmployee, \"oeyFvQkhdwa18cdX4M5OuFe74Yw=\", false, function () {\n  return [useCustomFetch];\n});","map":{"version":3,"names":["useCallback","useState","useEffect","useCustomFetch","useTransactionsByEmployee","fetchWithCache","loading","transactionsByEmployee","setTransactionsByEmployee","savedTransactions","localStorage","getItem","JSON","parse","fetchById","employeeId","data","prevTransactions","updatedTransactions","map","transaction","existingTransaction","find","t","id","approved","setItem","stringify","invalidateData","updateTransactionApproval","transactionId","newValue"],"sources":["D:/Assessments/Ramp/ramp-fe-challenge/src/hooks/useTransactionsByEmployee.ts"],"sourcesContent":["import { useCallback, useState, useEffect } from \"react\"\nimport { RequestByEmployeeParams, Transaction } from \"../utils/types\"\nimport { TransactionsByEmployeeResult } from \"./types\"\nimport { useCustomFetch } from \"./useCustomFetch\"\n\nexport function useTransactionsByEmployee(): TransactionsByEmployeeResult {\n  const { fetchWithCache, loading } = useCustomFetch()\n  const [transactionsByEmployee, setTransactionsByEmployee] = useState<Transaction[] | null>(null)\n\n  // ✅ Restore persisted transactions from localStorage on first load\n  useEffect(() => {\n    const savedTransactions = localStorage.getItem(\"transactionsByEmployee\")\n    if (savedTransactions) {\n      setTransactionsByEmployee(JSON.parse(savedTransactions))\n    }\n  }, [])\n\n  const fetchById = useCallback(\n    async (employeeId: string) => {\n      const data =\n        (await fetchWithCache<Transaction[], RequestByEmployeeParams>(\"transactionsByEmployee\", {\n          employeeId,\n        })) ?? [] // ✅ Ensure `data` is always an array\n\n      setTransactionsByEmployee((prevTransactions) => {\n        if (!prevTransactions) return data\n\n        const updatedTransactions = data.map((transaction) => {\n          const existingTransaction = prevTransactions.find((t) => t.id === transaction.id)\n          return existingTransaction\n            ? { ...transaction, approved: existingTransaction.approved }\n            : transaction\n        })\n\n        localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)) // ✅ Store merged transactions\n        return updatedTransactions\n      })\n    },\n    [fetchWithCache]\n  )\n\n  const invalidateData = useCallback(() => {\n    setTransactionsByEmployee(null)\n  }, [])\n\n  const updateTransactionApproval = useCallback((transactionId: string, newValue: boolean) => {\n    setTransactionsByEmployee((prevTransactions) => {\n      if (!prevTransactions) return null\n\n      const updatedTransactions = prevTransactions.map((t) =>\n        t.id === transactionId ? { ...t, approved: newValue } : t\n      )\n\n      localStorage.setItem(\"transactionsByEmployee\", JSON.stringify(updatedTransactions)) // ✅ Store changes persistently\n\n      return updatedTransactions\n    })\n  }, [])\n\n  return { data: transactionsByEmployee, loading, fetchById, invalidateData, updateTransactionApproval }\n}\n"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,QAAtB,EAAgCC,SAAhC,QAAiD,OAAjD;AAGA,SAASC,cAAT,QAA+B,kBAA/B;AAEA,OAAO,SAASC,yBAAT,GAAmE;EAAA;;EACxE,MAAM;IAAEC,cAAF;IAAkBC;EAAlB,IAA8BH,cAAc,EAAlD;EACA,MAAM,CAACI,sBAAD,EAAyBC,yBAAzB,IAAsDP,QAAQ,CAAuB,IAAvB,CAApE,CAFwE,CAIxE;;EACAC,SAAS,CAAC,MAAM;IACd,MAAMO,iBAAiB,GAAGC,YAAY,CAACC,OAAb,CAAqB,wBAArB,CAA1B;;IACA,IAAIF,iBAAJ,EAAuB;MACrBD,yBAAyB,CAACI,IAAI,CAACC,KAAL,CAAWJ,iBAAX,CAAD,CAAzB;IACD;EACF,CALQ,EAKN,EALM,CAAT;EAOA,MAAMK,SAAS,GAAGd,WAAW,CAC3B,MAAOe,UAAP,IAA8B;IAAA;;IAC5B,MAAMC,IAAI,4BACP,MAAMX,cAAc,CAAyC,wBAAzC,EAAmE;MACtFU;IADsF,CAAnE,CADb,yEAGD,EAHT,CAD4B,CAIhB;;IAEZP,yBAAyB,CAAES,gBAAD,IAAsB;MAC9C,IAAI,CAACA,gBAAL,EAAuB,OAAOD,IAAP;MAEvB,MAAME,mBAAmB,GAAGF,IAAI,CAACG,GAAL,CAAUC,WAAD,IAAiB;QACpD,MAAMC,mBAAmB,GAAGJ,gBAAgB,CAACK,IAAjB,CAAuBC,CAAD,IAAOA,CAAC,CAACC,EAAF,KAASJ,WAAW,CAACI,EAAlD,CAA5B;QACA,OAAOH,mBAAmB,GACtB,EAAE,GAAGD,WAAL;UAAkBK,QAAQ,EAAEJ,mBAAmB,CAACI;QAAhD,CADsB,GAEtBL,WAFJ;MAGD,CAL2B,CAA5B;MAOAV,YAAY,CAACgB,OAAb,CAAqB,wBAArB,EAA+Cd,IAAI,CAACe,SAAL,CAAeT,mBAAf,CAA/C,EAV8C,CAUsC;;MACpF,OAAOA,mBAAP;IACD,CAZwB,CAAzB;EAaD,CApB0B,EAqB3B,CAACb,cAAD,CArB2B,CAA7B;EAwBA,MAAMuB,cAAc,GAAG5B,WAAW,CAAC,MAAM;IACvCQ,yBAAyB,CAAC,IAAD,CAAzB;EACD,CAFiC,EAE/B,EAF+B,CAAlC;EAIA,MAAMqB,yBAAyB,GAAG7B,WAAW,CAAC,CAAC8B,aAAD,EAAwBC,QAAxB,KAA8C;IAC1FvB,yBAAyB,CAAES,gBAAD,IAAsB;MAC9C,IAAI,CAACA,gBAAL,EAAuB,OAAO,IAAP;MAEvB,MAAMC,mBAAmB,GAAGD,gBAAgB,CAACE,GAAjB,CAAsBI,CAAD,IAC/CA,CAAC,CAACC,EAAF,KAASM,aAAT,GAAyB,EAAE,GAAGP,CAAL;QAAQE,QAAQ,EAAEM;MAAlB,CAAzB,GAAwDR,CAD9B,CAA5B;MAIAb,YAAY,CAACgB,OAAb,CAAqB,wBAArB,EAA+Cd,IAAI,CAACe,SAAL,CAAeT,mBAAf,CAA/C,EAP8C,CAOsC;;MAEpF,OAAOA,mBAAP;IACD,CAVwB,CAAzB;EAWD,CAZ4C,EAY1C,EAZ0C,CAA7C;EAcA,OAAO;IAAEF,IAAI,EAAET,sBAAR;IAAgCD,OAAhC;IAAyCQ,SAAzC;IAAoDc,cAApD;IAAoEC;EAApE,CAAP;AACD;;GAvDezB,yB;UACsBD,c"},"metadata":{},"sourceType":"module"}